--Time between running normal system events
local cycle = 5
local monitor = peripheral.wrap("top")
local nuclearControlSystems = {}
local nuclearControlIds = {}
local currentPage = 0
local modemSide = "bottom"
local pageSize = 14
local timeOutAttempts = 5
local timeout = 1

--sends a message using nuclear control system protocol
--id: int
--nuclear control system id
--msg: string
--msg to send to nuclear control system
--return: boolean, any
--true if msg sent succesfully false if not, msg is whatever you were expecting back
local function send (id, msg)

	local rid = 0
	local rMsg = ""
	local connect = false
	
	for i = 1, timeOutAttempts do
	
		rednet.open(modemSide)
		rednet.send(id,msg)
		rid, rMsg = rednet.receive(timeout)
		rednet.close(modemSide)
		
		if rid == id and (type(rMsg) == "table" or (type(rMsg) == "string" and rMsg == "received")) then
			connect = true
			break
		end
	end
	
	return connect, rMsg
end

--Removes a nuclear control system
--id: int
--nuclear system id to be deleted
--returns: boolean
-- true if delete succesful false if unsuccesful
local function removeNuclearControlSystem (id)
	
	for i = 1, #nuclearControlIds do
		if nuclearControlId[i] == id then
			table.remove(nuclearControlSystems[id])
			table.remove(nuclearControlIds[i])
			return true
		end
	end
	
	return false
end

--Updates nuclearControlSystems table with current data
--id: int
--optional send number id to update a single nuclear control system
local function updateNuclearControlSystemsStats (...)

	
	local id = 0
	local msg = {}
	local received = false
	
	if args ~= nil then
		
		id = args[1]
		print("Attempting to udate "..id)
		
		if nuclearControlSystems[id].currentMode ~= "shutdown" then
			
			received, msg = send(id, "getStats")

			if received and type(msg) == "table" then
				print("Updating: "..id)
				nuclearControlSystems[id] = msg
			end
		end
		
	else
	
		for i = 1, #nuclearControlIds do
		
			id = nuclearControlIds[i]
			print("Attempting to udate "..id)
			--if nuclearControlSystems[id].currentMode ~= "shutdown" then
			
			received, msg = send(id, "getStats")
				
			if received and type(msg) == "table" then
				print("Updating: "..id)
				nuclearControlSystems[id] = msg
			end
			--end
		end
		
	end
	
end

--Draws the monitor
--page: int
--current page the monitor is on
local function drawMonitor(page)
	
	local n = 0
	local x = 1
	local y = 1
	local title = "Nuclear Command"
	local w,h = monitor.getSize()
	local totalEU = 0
	
	if page*pageSize + pageSize < #nuclearControlIds then
		n = page*pageSize + pageSize
	else
		n = #nuclearControlIds
	end
	
	monitor.clear()
	monitor.setTextColour(1)
	monitor.setTextScale(1)
	x = math.floor(math.floor(w - string.len(title))/2)
	monitor.setCursorPos(x,y)
	monitor.write(title)
	monitor.setTextScale(1)
	
	for i = page*pageSize + 1, n do
		
		local id = nuclearControlIds[i]
		local k = i
		x = (k%1) * 48 + 1
		y = 4 + math.floor(k/1)
		local nPos = 0
		local sPos = 14
		local euPos = 26
		local tPos = 38
		
		local temp = math.floor(tonumber(nuclearControlSystems[id].getHeat)/tonumber(nuclearControlSystems[id].getMaxHeat))
		local mode = ""
		totalEU = totalEU + nuclearControlSystems[id].getEUOutput
		
		monitor.setCursorPos(x+nPos,y)
		monitor.write("System #"..id)
		monitor.setCursorPos(x+sPos,y)
		
		if nuclearControlSystems[id].currentMode == "energy" then
			mode = "ENERGY"
			monitor.setTextColour(8192)
		elseif nuclearControlSystems[id].currentMode == "cooldown" then
			mode = "COOLDOWN"
			monitor.setTextColour(2048)
		else
			mode = "SHUTDOWN"
			monitor.setTextColour(16384)
		end
		
		monitor.write(mode)
		monitor.setTextColour(1)
		
		monitor.setCursorPos(x+euPos,y)
		monitor.write("EU: "..nuclearControlSystems[id].getEUOutput)
		monitor.setCursorPos(x+tPos,y)
		monitor.write("Temp: "..temp.."%")
	end
	
	local euString = "Total EU being produced: "..totalEU
	monitor.setTextColour(1)
	monitor.setTextScale(1)
	x = math.floor(math.floor(w - string.len(euString))/2)
	y = 2
	monitor.setCursorPos(x,y)
	monitor.write(euString)
	monitor.setCursorPos(1,1)
	
end

--Verifies if an id is a nuclear system id
--id: int
--Represents a possible computer id
--returns: boolean
--true if id exists in nuclearControlIds table else false
local function isNuclearSystemId (id)

	for i = 1, #nuclearControlIds do
		if id == nuclearControlIds[i] then
			return true
		end
	end

	return false
end

--handles all nuclear system events
--id: int
--a nuclear system id
--msg: table
--table containing nuclear system information
--returns: string
--return message
local function handleNuclearSystemEvent (id, msg)
	nuclearControlSystems[id] = msg
end

--Sends a command to one or all nuclear control systems
--id: int
--if id is 0 cmd will be broadcast to all nuclear control systems
--cmd: string
--command to send to nuclear control systems
--return: string
--msg received from nuclear control system
local function executeCommand (id, cmd)

	local received = false
	local rMsg = ""
	
	--It's poor design, but a very specific action needs to be taken if the cmd is disconnect
	if id > 0 then
	
		received, rMsg = send(id, cmd)
		
		if cmd == "disconnect" and received == true then
			removeNuclearControlSystem(id)
		end
		
	else
		for i = 1, #nuclearControlIds do
			
			received, rMsg = send(nuclearControlIds[i], cmd)
			
			if cmd == "disconnect" and received == true then
				removeNuclearControlSystem(nuclearControlIds[i])
			end
			
		end
	end
	
	if received then
		rMsg = ""
	else
		rMsg = "\""..cmd.."\" command not executed. Nuclear control system was busy."
	end
	
	return rMsg
end

--Handles any command events
--cmd: string
--String with the format of <cmd> <arg1> <arg2> <arg3> ...
--return: string
--a string return message (mostly for exiting program)
local function handleCommandEvent (cmd)
	
	--table with element 1 being the command and every element after an arg
	local c = {}
	local id = 0
	--return message
	local rMsg = ""
	
	print(cmd)
	--put individual words from the command into c
	for word, w in string.gmatch(cmd, "%a+") do 
		c[#c+1] = word
		print(word)
	end
	
	--handle each command
	
	--quits program
	if c[1] == "quit" then
		rMsg = c[1]
	elseif c[1] == "stop" then
			
		if #c > 1 then
			rMsg = executeCommand(c[2],c[1])
		else
			rMsg = executeCommand(0,c[1])
		end
		
	elseif c[1] == "start" then
	
		if #c > 1 then
			rMsg = executeCommand(c[2],c[1])
		else
			rMsg = executeCommand(0,c[1])
		end
		
	elseif c[1] == "shutdown" then
	
		if #c > 1 then
			rMsg = executeCommand(c[2],c[1])
		else
			rMsg = executeCommand(0,c[1])
		end
	elseif c[1] == "turnon" then
	
		if #c > 1 then
			rMsg = executeCommand(c[2],c[1])
		else
			rMsg = executeCommand(0,c[1])
		end
	elseif c[1] == "disconnect" then
		
		if #c > 1 then
			rMsg = executeCommand(c[2],c[1])
		else
			rMsg = executeCommand(0,c[1])
		end
	elseif c[1] == "draw" then
		drawMonitor(0)
	elseif c[1] == "quit" then
		rMsg = c[1]
	end
	
	
	return rMsg
end

--Handles normal system events
local function handleSystemEvent ()
	
	
	local msg = updateNuclearControlSystemsStats()
	
	drawMonitor(currentPage)
	
	return msg
end

--Handles any rednet events not from nuclear control systems
--id: int
--senders computer id
--msg: string
--senders msg
--returns: string
--return message
local function handleRednetMessageEvent (id, msg)

	local rMsg = ""
	
	return rMsg
end

--Adds nuclear control system to nuclearControlIds and sends a start command
--id: int
--nuclear control system id
local function addNuclearControlSystem (id)

	local exists = false
	
	for i = 1, #nuclearControlIds do
		if id == i then
			exist = true
			break
		end
	end
	
	if not exists then
		print("Adding "..id.." to nuclearControlIds")
		--add id to table
		nuclearControlIds[#nuclearControlIds + 1] = id
		nuclearControlSystems[id] = {getHeat = 0, getMaxHeat = 0, getEUOutput = 0, currentMode = ""}
	end
	
end

--waits for events and performs actions based on them 
-- t: int
-- time between performing system events
local function eventHandler ()
	local event = ""
	local id = 0
	local msg = ""
	local tid = os.startTimer(cycle)
	
	--get any event
	rednet.open(modemSide)
	event, id, msg = os.pullEvent()
	rednet.close(modemSide)

	
	--handle events
	if isNuclearSystemId(id) then
		msg = handleNuclearSystemEvent(id, msg)
		if msg ~= "" then print(msg) end
	elseif event == "rednet_message" then
		msg = handleRednetMessageEvent(id, msg)
		if msg ~= "" then print(msg) end
	elseif event == "key" then
		msg = handleCommandEvent(read())
		if msg ~= "" then print(msg) end
	elseif event == "timer" and id == tid then
		msg = handleSystemEvent()
		if msg ~= "" then print(msg) end		
	end
	
	os.cancelTimer(tid)
	
	return msg
end 

--initialize program
local function init ()
	
	local event = ""
	local id = 0
	local msg = ""
	
	print("Initializing system...")
	--Clear Monitor and start initialize timer
	monitor.clear()
	os.startTimer(10)
	
	while event ~= "timer" do
		
		rednet.open(modemSide)
		rednet.broadcast("nuclearControl")
		event, id, msg = os.pullEvent()
		rednet.close(modemSide)
		
		if event == "rednet_message" and msg == "nuclearCommand" then
			addNuclearControlSystem(id)
			rednet.open(modemSide)
			rednet.send(id, "start")
			rednet.close(modemSide)
		end
		
	end

	print("Initialization Complete!")
	print("Welcome to Nuclear Command!")
end

--Handles everything before a shutdown occurs
local function shutdown ()

	for i = 1, #nuclearControlIds do
		send(nuclearControlIds[i], "shutdown")
	end
	
end

--main function for program
local function main ()
	
	--initialize program
	init()
	
	--loop in eventHandler
	while true do
		
		local msg = eventHandler()

		if type(msg) == "string" then
		
			if msg == "quit" then
				break
			end
		
		end
		
	end
	
	--shutdown program
	shutdown()
	
end

--Run main program
main()