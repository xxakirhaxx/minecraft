--Time between running normal system events
local cycle = 5
local monitor = peripheral.wrap("top")
local nuclearControlSystems = {}
local modemSide = "bottom"

--Verifies if an id is a nuclear system id
--id: int
--Represents a possible computer id
--returns: boolean
--true if id exists in nuclearControlSystems table else false
local function isNuclearSystemId (id)

	for i = 1, #nuclearControlSystems do
		if id == nuclearControlSystems[i] then
			return true
		end
	end

	return false
end

--handles all nuclear system events
--id: int
--a nuclear system id
--msg: table
--table containing nuclear system information
--returns: string
--return message
local function handleNuclearSystemEvent (id, msg)

	local rMsg = ""
	
	return rMsg
end

--Handles any command events
--cmd: string
--String with the format of <cmd> <arg1> <arg2> <arg3> ...
--return: string
--a string return message (mostly for exiting program)
local function handleCommandEvent (cmd)
	--table with element 1 being the command and every element after an arg
	local c = {}
	--return message
	local rMsg = ""
	
	--put individual words from the command into c
	for word in string.gmatch(cmd, "%a+") do 
		c[#c+1] = word 
	end
	
	--handle each command
	
	--quits program
	if c[1] == "quit" then
		rMsg = c[1]
	elseif c[1] == "stop" then
		rednet.open(modemSide)
		rednet.broadcast("cooldown")
		rednet.close(modemSide)
	elseif c[1] == "start" then
		rednet.open(modemSide)
		rednet.broadcast("start")
		rednet.close(modemSide)
	elseif c[1] == "shutdown" then
		rednet.open(modemSide)
		rednet.broadcast("shutdown")
		rednet.close(modemSide)
	elseif c[1] == "disconnect" then
		rednet.open(modemSide)
		rednet.broadcast("start")
		rednet.close(modemSide)
	end
	
	
	return rMsg
end

--Handles normal system events
local function handleSystemEvent ()
	
end

--Handles any rednet events not from nuclear control systems
--id: int
--senders computer id
--msg: string
--senders msg
--returns: string
--return message
local function handleRednetMessageEvent (id, msg)

	local rMsg = ""
	
	return rMsg
end

--Adds nuclear control system to nuclearControlSystems and sends a start command
--id: int
--nuclear control system id
local function addNuclearControlSystem (id)

	--add id to table
	nuclearControlSystems[#nuclearControlSystems + 1] = id
	
	--send start message
	rednet.open(modemSide)
	rednet.send(id, "start")
	rednet.close(modemSide)
	
end

--waits for events and performs actions based on them 
-- t: int
-- time between performing system events
local function eventHandler (t)
	local event = ""
	local id = ""
	local msg = ""
	local tid = os.startTimer(t)
	
	--get any event
	rednet.open(modemSide)
	event, id, msg = os.pullEvent()
	print(event, " : " , id, " : ", msg)
	rednet.close(modemSide)
	
	os.cancelTimer(tid)

	
	--handle events
	if isNuclearSystemId(id) then
		msg = handleNuclearSystemEvent(id, msg)
	elseif event == "rednet_message" then
		msg = handleRednetMessageEvent(id, msg)
	elseif event == "key" then
		msg = handleCommandEvent(read())
	end
	
	handleSystemEvent()
	
	return {msg, t}
end 

--initialize program
local function init ()
	
	local event = ""
	local id = ""
	local msg = ""
	
	print("Initializing system...")
	--Clear Monitor and start initialize timer
	monitor.clear()
	os.startTimer(10)
	
	while event ~= "timer" do
		
		rednet.open(modemSide)
		rednet.broadcast("nuclearControl")
		event, id, msg = os.pullEvent()
		rednet.close(modemSide)
		
		if event == "rednet_message" and msg == "nuclearCommand" then
			addNuclearControlSystem(id)
		end
		
	end

	print("Initialization Complete!")
	print("Welcome to Nuclear Command!")
end

--Handles everything before a shutdown occurs
local function shutdown ()

	rednet.open(modemSide)
	rednet.broadcast("shutdown")
	rednet.close(modemSide)
	
end

--main function for program
local function main ()
	
	local t = cycle
	
	--initialize program
	init()
	
	--loop in eventHandler
	while true do
		
		local n = eventHandler(t)
		
		t = n[2]
		
		if type(n[1]) == "string" then
		
			if n[1] == "quit" then
				break
			end
		
		end
		
	end
	
	--shutdown program
	shutdown()
	
end

--Run main program
main()